# -*- coding: utf-8 -*-
"""Class for generating problem instances (in this case, weighted bipartite graphs).

Contains the InstanceGenerator class, which creates problem instances for uniform cardinal valuations under unit-sum and unit-range normalizations, in addition to risk-averse,
risk-neutral, and risk-loving utility functions. ALso logs all problem instances created by InstanceGenerator.

"""

import networkx as nx
import numpy as np
import pandas as pd

class InstanceGenerator:
    """Object that generates problem instances for the simulation.
    
    Attributes:
        logging (bool): Whether or not to log generated instances for this InstanceGenerator.
        history (dict): A dictionary containing all logged entries.
        index (int): an index representing the id of the next entry that will be logged.
        
    """

    def __init__(self, logging=False):
        """Initializes a new InstanceGenerator.
        
        Args:
            logging (bool): Whether or not all instances generated by this InstanceGenerator should be stored.
        """
        self.logging = logging
        self.history = {}
        self.index = 1


    def matrix_to_graph(self, M):
        """Helper method that transforms a square matrix into a weighted bipartite graph.
        
        Args:
            M (np.array): two-dimensional square numpy array, where rows represent agent preferences over goods, of size n.

        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.    
        """
        n=M.shape[0]
        G = nx.Graph()
        G.add_nodes_from(list(range(1, 2*n+1)))

        goods_array = np.array(list(range(n+1, 2*n+1)))

        for i in range(n):
            agent_array = np.array([i+1]*n)
            value_array = M[i]
            weight_data = np.array([agent_array, goods_array, value_array]).T
            G.add_weighted_edges_from(weight_data)

        return G


    def generate_unit_range_unif(self, n):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' valuations are drawn
        uniformly at random from the space of all unit-range valuations.
        
        Args:
            n (int): the number of agents in the bipartite graph. For unit-range to make sense, n must be 2 or greater
            
        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.
        """
        M = []
        for i in range(n):
            val = np.concatenate([np.array([0,1]), np.random.rand(n-2)], axis=0)
            np.random.shuffle(val)
            M.append(val)

        M = np.array(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)


    def generate_unit_sum_unif(self, n):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' valuations are drawn
        uniformly at random from the space of all unit-sum valuations.
        
        Args:
            n (int): the number of agents in the bipartite graph
            
        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.
        """
        M = []

        for i in range(n):
            #code for uniformly generating a point from the n-dimensional unit simplex
            cut = np.random.rand(n)
            cut = np.sort(cut)
            cut = np.insert(cut, 0, 0)
            val = [cut[j+1] - cut[j] for j in range(n)]
            val = np.array(val)
            np.random.shuffle(val)

            M.append(val)

        M = np.array(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)


    def normalize_unit_range(self, M):
        """Normalizes the given valuation matrix according to unit-range.

        Args:
            M (np.array): two-dimensional square numpy array, where rows represent agent preferences over goods, of size n, with the
            precondition that each row contains at least two distinct values.

        Returns:
            Two-dimensional numpy array where each row vector has a minimum value of 0 and a maximum value of 1.
        """
        min_array = np.min(M, axis=1)
        max_array = np.max(M, axis=1)
        return (M.T-min_array).T/(max_array-min_array) #hacky way to do row subtraction


    def normalize_unit_sum(self, M):
        """Normalizes the given valuation matrix according to unit-sum.

        Args:
            M (np.array): two-dimensional square numpy array, where rows represent agent preferences over goods, of size n.

        Returns:
            Two-dimensional numpy array where each row vector sums up to 1.
        """
        return (M.T/np.sum(M,axis=1)).T


    def arrow_valuation(self, n, alpha):
        """Generates an n x n matrix of agent valuations, where agents' ordinal preferences are drawn uniformly
        at random and their cardinal utilities are determined by Arrow's exponential utility model.

 
        Args:
            n (int): the number of agents in the valuation profile to be generated.
            alpha (float): the weight parameter on the utility function of the agent. Positive alpha represents a risk
            averse utility model, negative alpha represents a risk loving utility model, and zero alpha represents a
            risk neutral utility model.

        Returns:     
            Two-dimensional numpy array where each row represents agent preferences.
        """
        #generate random permutation of ranks over the items
        M = []

        for i in range(n):
            val = np.array(range(1,n+1))
            np.random.shuffle(val)

            if alpha == 0:
                val = n - val
            else:
                val = -alpha*(n - val)
                val = np.exp(val)
                val = 1/alpha * (1 - val)

            #unit-range normalization
            M.append(val)

        return np.array(M)


    def benabbou_valuation(self, n, salary_mean, salary_variance, price_lower, price_upper):
        """Generates an n x n matrix of valuations equivalent to the price-based utility model used in Benabbou et. al 2019 to investigate housing 
        assignment in Singapore: https://arxiv.org/pdf/1711.10241.pdf. This model assumes each agent has utility for a house based on their own 
        salary (drawn iid from a normal distribution), and the price of that house (drawn uniformly at random from a continuous interval).

        Args:
            n (int): the number of agents in the valuation profile to be generated.
            salary_mean (float): the mean salary of an agent for the model.
            salary_variance (float): the variance in salary of an agent for the model.
            price_lower (float): the lower bound of a house's price in the model
            price_upper (float): the upper bound of a house's price in the model.

         Returns:     
            Two-dimensional numpy array where each row represents agent preferences.       
        """
        agent_salaries = np.random.normal(salary_mean, np.sqrt(salary_variance), n)
        house_prices = np.random.uniform(price_lower, price_upper, n)
        M = (np.tile(house_prices, (n,1)).T - (agent_salaries/3)).T
        M = M ** 2
        return np.reciprocal(M)


    def abdulkadiroglu_valuation(self, n, alpha):
        """Generates an n x n matrix of valuations equivalent to the utility model used in Abdulkadiroglu et. all 2015 to investigate improving
        deferred acceptance in the context of school choice: https://www.aeaweb.org/articles?id=10.1257/mic.20120027. This model assumes each
        agent's utility for a given good is equal to some convex combination of an underlying value for the good (chosen uniformly from [0,1]),
        and that agent's particular value for the good (also chosen uniformly from [0,1]).

        Args:
            n (int): number of agents in the valuation profile to be generated.
            alpha (float): how much weight should be assigned to the underlying value for the good. Must be a float in [0,1].

        Returns:
            Two-dimensional numpy array where each row represents agent preferences.
        """
        agent_good_matrix = np.random.rand(n,n)
        good_vector = np.random.rand(n)
        return (1-alpha)*agent_good_matrix + alpha*good_vector



    def generate_unit_range_arrow(self, n, alpha):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' ordinal preferences
        are drawn uniformly at random and their cardinal utilities are determined by Arrow's exponential utility model,
        then normalized to the unit-range constraint.

        Args:
            n (int): the number of agents in the bipartite graph. n must be at least 2 for the unit-range case.
            alpha (float): the weight parameter on the utility function of the agent. Positive alpha represents a risk
            averse utility model, negative alpha represents a risk loving utility model, and zero alpha represents a
            risk neutral utility model.

        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.        
        """
        M = self.arrow_valuation(n, alpha)
        M = self.normalize_unit_range(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)


    def generate_unit_sum_arrow(self, n, alpha):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' ordinal preferences
        are drawn uniformly at random and their cardinal utilities are determined by Arrow's exponential utility model,
        then normalized to the unit-sum constraint.

        Args:
            n (int): the number of agents in the bipartite graph. n must be at least 2 for the unit-range case.
            alpha (float): the weight parameter on the utility function of the agent. Positive alpha represents a risk
            averse utility model, negative alpha represents a risk loving utility model, and zero alpha represents a
            risk neutral utility model.

        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.        
        """
        M = self.arrow_valuation(n, alpha)
        M = self.normalize_unit_sum(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)


    def generate_unit_range_benabbou(self, n, salary_mean, salary_variance, price_lower, price_upper):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' preferences are created
        according to the price-utility model created by Benabbou et. al 2019: https://arxiv.org/pdf/1711.10241.pdf, normalized
        to the unit-range constraint.

        Args:
            n (int): the number of agents in the instance to be generated.
            salary_mean (float): the mean salary of an agent for the model.
            salary_variance (float): the variance in salary of an agent for the model.
            price_lower (float): the lower bound of a house's price in the model
            price_upper (float): the upper bound of a house's price in the model.

         Returns:   
            Weighted bipartite Graph, with nodes 1 through n representing agents.          
        """
        M = self.benabbou_valuation(n, salary_mean, salary_variance, price_lower, price_upper)
        M = self.normalize_unit_range(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)


    def generate_unit_sum_benabbou(self, n, salary_mean, salary_variance, price_lower, price_upper):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' preferences are created
        according to the price-utility model created by Benabbou et. al 2019: https://arxiv.org/pdf/1711.10241.pdf, normalized
        to the unit-sum constraint.

        Args:
            n (int): the number of agents in the instance to be generated.
            salary_mean (float): the mean salary of an agent for the model.
            salary_variance (float): the variance in salary of an agent for the model.
            price_lower (float): the lower bound of a house's price in the model
            price_upper (float): the upper bound of a house's price in the model.

         Returns:   
            Weighted bipartite Graph, with nodes 1 through n representing agents.          
        """
        M = self.benabbou_valuation(n, salary_mean, salary_variance, price_lower, price_upper)
        M = self.normalize_unit_sum(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)


    def generate_unit_range_abdulkadiroglu(self, alpha, n):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' preferences are created according to
        the model suggested by Abdulkadiroglu et. al 2015: https://www.aeaweb.org/articles?id=10.1257/mic.20120027, normalized to
        the unit-range constraint.

        Args:
            n (int): number of agents in the valuation profile to be generated.
            alpha (float): how much weight should be assigned to the underlying value for the good. Must be a float in [0,1].

        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents. 
        """
        M = self.abdulkadiroglu_valuation(n, alpha)
        M = self.normalize_unit_range(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)


    def generate_unit_sum_abdulkadiroglu(self, alpha, n):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' preferences are created according to
        the model suggested by Abdulkadiroglu et. al 2015: https://www.aeaweb.org/articles?id=10.1257/mic.20120027, normalized to
        the unit-sum constraint.

        Args:
            n (int): number of agents in the valuation profile to be generated.
            alpha (float): how much weight should be assigned to the underlying value for the good. Must be a float in [0,1].

        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents. 
        """
        M = self.abdulkadiroglu_valuation(n, alpha)
        M = self.normalize_unit_sum(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)