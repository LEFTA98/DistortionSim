# -*- coding: utf-8 -*-
"""Class for generating problem instances (in this case, weighted bipartite graphs).

Contains the InstanceGenerator class, which creates problem instances for uniform cardinal valuations under unit-sum and unit-range normalizations, in addition to risk-averse,
risk-neutral, and risk-loving utility functions. ALso logs all problem instances created by InstanceGenerator.

"""

import networkx as nx
import numpy as np
import pandas as pd

class InstanceGenerator:
    """Object that generates problem instances for the simulation.
    
    Attributes:
        logging (bool): Whether or not to log generated instances for this InstanceGenerator.
        history (dict): A dictionary containing all logged entries.
        index (int): an index representing the id of the next entry that will be logged.
        
        
    
    """

    def __init__(self, logging=False):
        """Initializes a new InstanceGenerator.
        
        Args:
            logging (bool): Whether or not all instances generated by this InstanceGenerator should be stored.
        """
        self.logging = logging
        self.history = {}
        self.index = 1

    def matrix_to_graph(self, M):
        """Helper method that transforms a square matrix into a weighted bipartite graph.
        
        Args:
            M (np.array): two-dimensional square numpy array, where rows represent agent preferences over goods, of size n.

        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.    
        """
        n=M.shape[0]
        G = nx.Graph()
        G.add_nodes_from(list(range(1, 2*n+1)))

        goods_array = np.array(list(range(n+1, 2*n+1)))

        for i in range(n):
            agent_array = np.array([i+1]*n)
            value_array = M[i]
            weight_data = np.array([agent_array, goods_array, value_array]).T
            G.add_weighted_edges_from(weight_data)

        return G

    def generate_unit_range_unif(self, n):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' valuations are drawn
        uniformly at random from the space of all unit-range valuations.
        
        Args:
            n (int): the number of agents in the bipartite graph. For unit-range to make sense, n must be 2 or greater
            
        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.
        """
        M = []
        for i in range(n):
            val = np.concatenate([np.array([0,1]), np.random.rand(n-2)], axis=0)
            np.random.shuffle(val)
            M.append(val)

        M = np.array(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)

    def generate_unit_sum_unif(self, n):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' valuations are drawn
        uniformly at random from the space of all unit-sum valuations.
        
        Args:
            n (int): the number of agents in the bipartite graph
            
        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.
        """
        M = []

        for i in range(n):
            #code for uniformly generating a point from the n-dimensional unit simplex
            cut = np.random.rand(n)
            cut = np.sort(cut)
            cut = np.insert(cut, 0, 0)
            val = [cut[j+1] - cut[j] for j in range(n)]
            val = np.array(val)
            np.random.shuffle(val)

            M.append(val)

        M = np.array(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)


    def generate_unit_range_arrow(self, n, alpha):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' ordinal preferences
        are drawn uniformly at random and their cardinal utilities are determined by Arrow's exponential utility model,
        then normalized to the unit-range constraint.

        Args:
            n (int): the number of agents in the bipartite graph. n must be at least 2 for the unit-range case.
            alpha (float): the weight parameter on the utility function of the agent. Positive alpha represents a risk
            averse utility model, negative alpha represents a risk loving utility model, and zero alpha represents a
            risk neutral utility model.

        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.        
        """
        #generate random permutation of ranks over the items
        M = []

        for i in range(n):
            val = np.array(range(1,n+1))
            np.random.shuffle(val)

            if alpha == 0:
                val = n - val
            else:
                val = -alpha*(n - val)
                val = np.exp(val)
                val = 1/alpha * (1 - val)

            #unit-range normalization
            M.append(val/np.max(val))

        M = np.array(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)


    #TODO should we consider collapsing this function and the above one into a single function?
    def generate_unit_sum_arrow(self, n, alpha):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' ordinal preferences
        are drawn uniformly at random and their cardinal utilities are determined by Arrow's exponential utility model,
        then normalized to the unit-sum constraint.

        Args:
            n (int): the number of agents in the bipartite graph. n must be at least 2 for the unit-range case.
            alpha (float): the weight parameter on the utility function of the agent. Positive alpha represents a risk
            averse utility model, negative alpha represents a risk loving utility model, and zero alpha represents a
            risk neutral utility model.

        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.        
        """
        #generate random permutation of ranks over the items
        M = []

        for i in range(n):
            val = np.array(range(1,n+1))
            np.random.shuffle(val)

            if alpha == 0:
                val = n - val
            else:
                val = -alpha*(n - val)
                val = np.exp(val)
                val = 1/alpha * (1 - val)

            #unit-sum normalization
            M.append(val/np.sum(val))

        M = np.array(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)
