# -*- coding: utf-8 -*-
"""Class for generating problem instances (in this case, weighted bipartite graphs).

Contains the InstanceGenerator class, which creates problem instances for uniform cardinal valuations under unit-sum and unit-range normalizations, in addition to risk-averse,
risk-neutral, and risk-loving utility functions. ALso logs all problem instances created by InstanceGenerator.

"""

import networkx as nx
import numpy as np
import pandas as pd

class InstanceGenerator:
    """Object that generates problem instances for the simulation.
    
    Attributes:
        logging (bool): Whether or not to log generated instances for this InstanceGenerator.
        history (dict): A dictionary containing all logged entries.
        index (int): an index representing the id of the next entry that will be logged.
        
        
    
    """

    def __init__(self, logging=False):
        """Initializes a new InstanceGenerator.
        
        Args:
            logging (bool): Whether or not all instances generated by this InstanceGenerator should be stored.
        """
        self.logging = logging
        self.history = {}
        self.index = 1


    def matrix_to_graph(self, M):
        """Helper method that transforms a square matrix into a weighted bipartite graph.
        
        Args:
            M (np.array): two-dimensional square numpy array, where rows represent agent preferences over goods, of size n.

        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.    
        """
        n=M.shape[0]
        G = nx.Graph()
        G.add_nodes_from(list(range(1, 2*n+1)))

        goods_array = np.array(list(range(n+1, 2*n+1)))

        for i in range(n):
            agent_array = np.array([i+1]*n)
            value_array = M[i]
            weight_data = np.array([agent_array, goods_array, value_array]).T
            G.add_weighted_edges_from(weight_data)

        return G


    def generate_unit_range_unif(self, n):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' valuations are drawn
        uniformly at random from the space of all unit-range valuations.
        
        Args:
            n (int): the number of agents in the bipartite graph. For unit-range to make sense, n must be 2 or greater
            
        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.
        """
        M = []
        for i in range(n):
            val = np.concatenate([np.array([0,1]), np.random.rand(n-2)], axis=0)
            np.random.shuffle(val)
            M.append(val)

        M = np.array(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)


    def generate_unit_sum_unif(self, n):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' valuations are drawn
        uniformly at random from the space of all unit-sum valuations.
        
        Args:
            n (int): the number of agents in the bipartite graph
            
        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.
        """
        M = []

        for i in range(n):
            #code for uniformly generating a point from the n-dimensional unit simplex
            cut = np.random.rand(n)
            cut = np.sort(cut)
            cut = np.insert(cut, 0, 0)
            val = [cut[j+1] - cut[j] for j in range(n)]
            val = np.array(val)
            np.random.shuffle(val)

            M.append(val)

        M = np.array(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)


    def normalize_unit_range(self, M):
        """Normalizes the given valuation matrix according to unit-range.

        Args:
            M (np.array): two-dimensional square numpy array, where rows represent agent preferences over goods, of size n, with the
            precondition that each row contains at least two distinct values.

        Returns:
            Two-dimensional numpy array where each row vector has a minimum value of 0 and a maximum value of 1.
        """
        min_array = np.min(M, axis=1)
        max_array = np.max(M, axis=1)
        return (M.T-min_array).T/(max_array-min_array) #hacky way to do row subtraction


    def normalize_unit_sum(self, M):
        """Normalizes the given valuation matrix according to unit-sum.

        Args:
            M (np.array): two-dimensional square numpy array, where rows represent agent preferences over goods, of size n.

        Returns:
            Two-dimensional numpy array where each row vector sums up to 1.
        """
        return (M.T/np.sum(M,axis=1)).T


    def arrow_valuation(self, n, alpha):
        """Generates an n x n matrix of agent valuations, where agents' ordinal preferences are drawn uniformly
        at random and their cardinal utilities are determined by Arrow's exponential utility model.

 
        Args:
            n (int): the number of agents in the valuation profile to be generated.
            alpha (float): the weight parameter on the utility function of the agent. Positive alpha represents a risk
            averse utility model, negative alpha represents a risk loving utility model, and zero alpha represents a
            risk neutral utility model.

        Returns:     
            Two-dimensional numpy array where each row represents agent preferences.
        """
        #generate random permutation of ranks over the items
        M = []

        for i in range(n):
            val = np.array(range(1,n+1))
            np.random.shuffle(val)

            if alpha == 0:
                val = n - val
            else:
                val = -alpha*(n - val)
                val = np.exp(val)
                val = 1/alpha * (1 - val)

            #unit-range normalization
            M.append(val)

        return np.array(M)


    def benabbou_valuation(self, n, salary_mean, salary_variance, price_lower, price_upper):
        """Generates an n x n matrix of valuations equivalent to the model used in Benabbou et. al 2019 to investigate housing assignment in 
        Singapore: https://arxiv.org/pdf/1711.10241.pdf. This model assumes each agent has utility for a house based on their own salary (drawn
        iid from a normal distribution), and the price of that house (drawn uniformly at random from a continuous interval).

        Args:
            n (int): the number of agents in the valuation profile to be generated.
            salary_mean (float): the mean salary of an agent for the model.
            salary_variance (float): the variance in salary of an agent for the model.
            price_lower (float): the lower bound of a house's price in the model
            price_upper (float): the upper bound of a house's price in the model.
        """
        pass


    def generate_unit_range_arrow(self, n, alpha):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' ordinal preferences
        are drawn uniformly at random and their cardinal utilities are determined by Arrow's exponential utility model,
        then normalized to the unit-range constraint.

        Args:
            n (int): the number of agents in the bipartite graph. n must be at least 2 for the unit-range case.
            alpha (float): the weight parameter on the utility function of the agent. Positive alpha represents a risk
            averse utility model, negative alpha represents a risk loving utility model, and zero alpha represents a
            risk neutral utility model.

        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.        
        """
        M = self.arrow_valuation(n, alpha)
        M = self.normalize_unit_range(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)


    def generate_unit_sum_arrow(self, n, alpha):
        """Generates a new instance of a weighted bipartite graph with 2n nodes, where agents' ordinal preferences
        are drawn uniformly at random and their cardinal utilities are determined by Arrow's exponential utility model,
        then normalized to the unit-sum constraint.

        Args:
            n (int): the number of agents in the bipartite graph. n must be at least 2 for the unit-range case.
            alpha (float): the weight parameter on the utility function of the agent. Positive alpha represents a risk
            averse utility model, negative alpha represents a risk loving utility model, and zero alpha represents a
            risk neutral utility model.

        Returns:
            Weighted bipartite Graph, with nodes 1 through n representing agents.        
        """
        M = self.arrow_valuation(n, alpha)
        M = self.normalize_unit_sum(M)

        if self.logging:
            self.history[self.index] = M
            self.index += 1

        return self.matrix_to_graph(M)

